{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Containers, Docker and Kubernetes for Beginners As a Software Developer, my day to day job includes building Applications, APIs, etc. I use some popular frameworks such as Python-Flask, NodeJs-Express to build the applications or APIs. When I started my career, I would code an application and run it on my machine. And if a friend/colleague asked for the application, I would share the GitHub link and provide a set of instructions to get the app running on their machine. As naive as I sounded, I realized that is not how you distribute an application. There are best practices such as containerizing the application and deploying it on a Kubernetes cluster. Hence I started learning Containers, Docker and Kubernetes. There is a lot of good learning content on the internet. However, I still used to end up with challenges quite often. Challenges such as: \"not knowing how to write a dockerfile\", \"dockerfile failed to build\", \"though the dockerfile built successfully, the image size would be large\", \"not knowing to write deployment scripts\", \"unable to access the deployed app from Kubernetes cluster\", and the list goes on. Now that I'm a Senior Software Developer with 2+ years of experience in the IT field, I reflect on how Containers, Docker and Kubernetes made a difference to my application distribution. Hence I decided to simplify the topic \"Containers, Docker and Kubernetes\" and share my learnings and expertise with the developers, especially the beginners, through this simple hands-on tutorial. In this tutorial, you will learn: How to build a basic python flask app or a basic NodeJs Express app Containarize the application Store it in container registry Write a deployment script Deploy it on a kubernetes cluster Pre-requisite Python 3.x Docker Account Docker CLI Kubernetes Cluster Kubectl CLI Steps graph LR; A[Application]-->B[Container Image]; B-->C[Store image in Container Registry]; C-->D[Deploy on Kubernetes]; Developing a basic Python or NodeJs Application Containerizing the Application Storing the Container Image in a Container Registry Writing the deployment scripts Deploying the Application on a Kubernetes Cluster","title":"Introduction"},{"location":"#containers-docker-and-kubernetes-for-beginners","text":"As a Software Developer, my day to day job includes building Applications, APIs, etc. I use some popular frameworks such as Python-Flask, NodeJs-Express to build the applications or APIs. When I started my career, I would code an application and run it on my machine. And if a friend/colleague asked for the application, I would share the GitHub link and provide a set of instructions to get the app running on their machine. As naive as I sounded, I realized that is not how you distribute an application. There are best practices such as containerizing the application and deploying it on a Kubernetes cluster. Hence I started learning Containers, Docker and Kubernetes. There is a lot of good learning content on the internet. However, I still used to end up with challenges quite often. Challenges such as: \"not knowing how to write a dockerfile\", \"dockerfile failed to build\", \"though the dockerfile built successfully, the image size would be large\", \"not knowing to write deployment scripts\", \"unable to access the deployed app from Kubernetes cluster\", and the list goes on. Now that I'm a Senior Software Developer with 2+ years of experience in the IT field, I reflect on how Containers, Docker and Kubernetes made a difference to my application distribution. Hence I decided to simplify the topic \"Containers, Docker and Kubernetes\" and share my learnings and expertise with the developers, especially the beginners, through this simple hands-on tutorial. In this tutorial, you will learn: How to build a basic python flask app or a basic NodeJs Express app Containarize the application Store it in container registry Write a deployment script Deploy it on a kubernetes cluster","title":"Containers, Docker and Kubernetes for Beginners"},{"location":"#pre-requisite","text":"Python 3.x Docker Account Docker CLI Kubernetes Cluster Kubectl CLI","title":"Pre-requisite"},{"location":"#steps","text":"graph LR; A[Application]-->B[Container Image]; B-->C[Store image in Container Registry]; C-->D[Deploy on Kubernetes]; Developing a basic Python or NodeJs Application Containerizing the Application Storing the Container Image in a Container Registry Writing the deployment scripts Deploying the Application on a Kubernetes Cluster","title":"Steps"},{"location":"build/","text":"Python Flask Application NodeJs Express Application Build a Python Flask App 1.1. Create a python virtual environment As a best practice create a Virtual Environment to get started. In terminal, run the following command: pip install virtualenv virtualenv venv Once the virtualenv is created, source into the venv by running the following command: source venv/bin/activate You will see the prompt change to (venv)$ . 1.2. Install flask library Since we are building a flask app make sure to install the flask library, by running the following command: pip install flask 1.3. Create a python app Create an app.py file by running the following command: touch app.py Open the app.py in your favourite code editor. Import the flask module from flask import Flask Set app context app = Flask ( __name__ ) Define a route for / @app . route ( '/' ) def index (): return \"<h1 align='center'>Hello World from Python Flask!</h1>\" Finally set the flask run if __name__ == \"__main__\" : app . run ( host = '0.0.0.0' , port = 8080 , debug = True , use_reloader = True ) Your app.py file should look something like this: app.py 1 2 3 4 5 6 7 8 9 10 from flask import Flask app = Flask ( __name__ ) @app . route ( '/' ) def index (): return \"<h1 align='center'>Hello World from Python Flask!</h1>\" if __name__ == \"__main__\" : app . run ( host = '0.0.0.0' , port = 8080 , debug = True , use_reloader = True ) Save the file. 1.4. Run the App Back to terminal, run the following command to start the application and check whether it works python app.py You will see output similar to the following: * Serving Flask app \"app\" (lazy loading) * Environment: production WARNING: This is a development server. Do not use it in a production deployment. Use a production WSGI server instead. * Debug mode: on * Running on http://0.0.0.0:8080/ (Press CTRL+C to quit) * Restarting with stat * Debugger is active! * Debugger PIN: 812*299*939 Visit http://0.0.0.0:8080/ on your browser or run the following command: curl http://0.0.0.0:8080 You will see output similar to the following: <h1 align='center'>Hello World from Python Flask!</h1> If you see Hello World message, congrats you have successfully built the basic flask application. Build a NodeJs Express App 1.1. Initialize Node Environment Initialize a new project by running the following command: npm init 1.2. Install Express library Since we are building an Express app make sure to install the Express library by running the following command: npm install express A package.json file will be created in the root directory of your project. 1.3. Set npm start command Add app.js to the package.json scripts section: \"scripts\" : { \"start\" : \"node app.js\" , \"test\" : \"echo \\\"Error: no test specified\\\" && exit 1\" }, 1.4. Create a NodeJs Express app Create an app.js file by running the following command: touch app.js Open the app.js in your favourite code editor. Import the express module const express = require ( 'express' ); Set app context const app = express (); Set port on which you want the app to listen const port = 3000 ; Define a route for / app . get ( '/' , ( req , res ) => { res . send ( \"<h1 align='center'>Hello World from NodeJs Express!</h1>\" ); }); Finally set the express run app . listen ( port , () => { console . log ( `Example app listening on port ${ port } !` ); }); Your app.js file should look something like this: app.js 1 2 3 4 5 6 7 8 9 10 11 const express = require ( 'express' ); const app = express (); const port = 3000 ; app . get ( '/' , ( req , res ) => { res . send ( \"<h1 align='center'>Hello World from NodeJs Express!</h1>\" ); }); app . listen ( port , () => { console . log ( `Example app listening on port ${ port } !` ); }); Save the file. 1.5. Run the App Back to terminal, run the following command to start the application and check whether it works npm start You will see output similar to the following: Example app listening on port 3000! Visit http://0.0.0.0:3000/ on your browser or run the following command: curl http://0.0.0.0:3000 You will see output similar to the following: <h1 align='center'>Hello World from Python Flask!</h1> If you see Hello World message, congrats you have successfully built the basic express application.","title":"1. Developing a basic Python or NodeJs Application"},{"location":"build/#build-a-python-flask-app","text":"","title":"Build a Python Flask App"},{"location":"build/#11-create-a-python-virtual-environment","text":"As a best practice create a Virtual Environment to get started. In terminal, run the following command: pip install virtualenv virtualenv venv Once the virtualenv is created, source into the venv by running the following command: source venv/bin/activate You will see the prompt change to (venv)$ .","title":"1.1. Create a python virtual environment"},{"location":"build/#12-install-flask-library","text":"Since we are building a flask app make sure to install the flask library, by running the following command: pip install flask","title":"1.2. Install flask library"},{"location":"build/#13-create-a-python-app","text":"Create an app.py file by running the following command: touch app.py Open the app.py in your favourite code editor. Import the flask module from flask import Flask Set app context app = Flask ( __name__ ) Define a route for / @app . route ( '/' ) def index (): return \"<h1 align='center'>Hello World from Python Flask!</h1>\" Finally set the flask run if __name__ == \"__main__\" : app . run ( host = '0.0.0.0' , port = 8080 , debug = True , use_reloader = True ) Your app.py file should look something like this: app.py 1 2 3 4 5 6 7 8 9 10 from flask import Flask app = Flask ( __name__ ) @app . route ( '/' ) def index (): return \"<h1 align='center'>Hello World from Python Flask!</h1>\" if __name__ == \"__main__\" : app . run ( host = '0.0.0.0' , port = 8080 , debug = True , use_reloader = True ) Save the file.","title":"1.3. Create a python app"},{"location":"build/#14-run-the-app","text":"Back to terminal, run the following command to start the application and check whether it works python app.py You will see output similar to the following: * Serving Flask app \"app\" (lazy loading) * Environment: production WARNING: This is a development server. Do not use it in a production deployment. Use a production WSGI server instead. * Debug mode: on * Running on http://0.0.0.0:8080/ (Press CTRL+C to quit) * Restarting with stat * Debugger is active! * Debugger PIN: 812*299*939 Visit http://0.0.0.0:8080/ on your browser or run the following command: curl http://0.0.0.0:8080 You will see output similar to the following: <h1 align='center'>Hello World from Python Flask!</h1> If you see Hello World message, congrats you have successfully built the basic flask application.","title":"1.4. Run the App"},{"location":"build/#build-a-nodejs-express-app","text":"","title":"Build a NodeJs Express App"},{"location":"build/#11-initialize-node-environment","text":"Initialize a new project by running the following command: npm init","title":"1.1. Initialize Node Environment"},{"location":"build/#12-install-express-library","text":"Since we are building an Express app make sure to install the Express library by running the following command: npm install express A package.json file will be created in the root directory of your project.","title":"1.2. Install Express library"},{"location":"build/#13-set-npm-start-command","text":"Add app.js to the package.json scripts section: \"scripts\" : { \"start\" : \"node app.js\" , \"test\" : \"echo \\\"Error: no test specified\\\" && exit 1\" },","title":"1.3. Set npm start command"},{"location":"build/#14-create-a-nodejs-express-app","text":"Create an app.js file by running the following command: touch app.js Open the app.js in your favourite code editor. Import the express module const express = require ( 'express' ); Set app context const app = express (); Set port on which you want the app to listen const port = 3000 ; Define a route for / app . get ( '/' , ( req , res ) => { res . send ( \"<h1 align='center'>Hello World from NodeJs Express!</h1>\" ); }); Finally set the express run app . listen ( port , () => { console . log ( `Example app listening on port ${ port } !` ); }); Your app.js file should look something like this: app.js 1 2 3 4 5 6 7 8 9 10 11 const express = require ( 'express' ); const app = express (); const port = 3000 ; app . get ( '/' , ( req , res ) => { res . send ( \"<h1 align='center'>Hello World from NodeJs Express!</h1>\" ); }); app . listen ( port , () => { console . log ( `Example app listening on port ${ port } !` ); }); Save the file.","title":"1.4. Create a NodeJs Express app"},{"location":"build/#15-run-the-app","text":"Back to terminal, run the following command to start the application and check whether it works npm start You will see output similar to the following: Example app listening on port 3000! Visit http://0.0.0.0:3000/ on your browser or run the following command: curl http://0.0.0.0:3000 You will see output similar to the following: <h1 align='center'>Hello World from Python Flask!</h1> If you see Hello World message, congrats you have successfully built the basic express application.","title":"1.5. Run the App"},{"location":"conclusion/","text":"In this tutorial, you learned: How to build a basic python flask app or a basic NodeJs Express app Containarize the application Store it in container registry Write a deployment script Deploy it on a kubernetes cluster You can access the source code of this tutorial at: Source code for the Python Flask Application Source code for the NodeJs Express Application Additional resources Docker Essentials: A Developer Introduction Containerization Explained Kubernetes vs. Docker: It's Not an Either/Or Question Docker and Kubernetes Tutorial | Full Course [2021] Tutorial created and maintained by Manoj Jahgirdar Questions If you have any questions or issues you can create a new issue here .","title":"Conclusion"},{"location":"containerize/","text":"Python Flask Application NodeJs Express Application Containerize Python Flask App 2.1. Create a Dockerfile Create a Dockerfile . In terminal, run the following command: touch Dockerfile Create a python library requirements file by running the following command: pip freeze > requirements.txt This will create a requirements.txt file in the same directory which will contain all the dependencies for the project. Open the Dockerfile in your favourite code editor. Define a base image FROM python:3.9-slim Create a working directory WORKDIR /app Add the app.py and requirements.txt file to the working directory ADD . /app Install the python dependencies RUN pip install --trusted-host pypi.python.org -r requirements.txt Expose the flask access port EXPOSE 8080 Run the python run command CMD [ \"python\" , \"-u\" , \"app.py\" ] Your Dockerfile should look something like this: Dockerfile 1 2 3 4 5 6 7 8 9 10 11 FROM python:3.9-slim WORKDIR /app ADD . /app RUN pip install --trusted-host pypi.python.org -r requirements.txt EXPOSE 8080 CMD [ \"python\" , \"-u\" , \"app.py\" ] Save the file. 2.2. Build Container Image Back to terminal, run the following command to build a container image for the application. docker build -t sample-app:v1.0 . You will see output similar to the following: => [internal] load build definition from Dockerfile 0.0s => => transferring dockerfile: 203B 0.0s => [internal] load .dockerignore 0.0s => => transferring context: 2B 0.0s => [internal] load metadata for docker.io/library/python:3.9-slim 4.1s => [auth] library/python:pull token for registry-1.docker.io 0.0s => [internal] load build context 0.3s => => transferring context: 15.34MB 0.3s => [1/4] FROM docker.io/library/python:3.9-slim@sha256:7783d80eca13fb9f8cfd8b 5.7s => => resolve docker.io/library/python:3.9-slim@sha256:7783d80eca13fb9f8cfd8b 0.0s => => sha256:7783d80eca13fb9f8cfd8b84b27ac09ecc28f52bafdd9b94 1.86kB / 1.86kB 0.0s => => sha256:9fa920a5e22c494e2c879fee24f72ba0bb842b8e8e7376ac 1.37kB / 1.37kB 0.0s => => sha256:afaa64e7c7fe503b643b460295b8621f4709ebd058c55c2b 7.63kB / 7.63kB 0.0s => => sha256:69692152171afee1fd341febc390747cfca2ff302f2881 27.15MB / 27.15MB 3.3s => => sha256:59773387c0e7ec4b901649cd3530cde9a32e6a76fccaf0b0 2.77MB / 2.77MB 3.0s => => sha256:3fc84e535e87f5dfd4ab5a3086531224f67051d7f7853c 10.93MB / 10.93MB 4.2s => => sha256:68ebeebdab6f71c7a8dc8532e56ed6d69171502240306980ae78 234B / 234B 4.2s => => extracting sha256:69692152171afee1fd341febc390747cfca2ff302f2881d8b394e 1.2s => => sha256:ada7ec54b5b23c775e12472f8975b1af576ca949c63a7957 2.60MB / 2.60MB 4.2s => => extracting sha256:59773387c0e7ec4b901649cd3530cde9a32e6a76fccaf0b015119 0.2s => => extracting sha256:3fc84e535e87f5dfd4ab5a3086531224f67051d7f7853c659d3dd 0.5s => => extracting sha256:68ebeebdab6f71c7a8dc8532e56ed6d69171502240306980ae78e 0.0s => => extracting sha256:ada7ec54b5b23c775e12472f8975b1af576ca949c63a795703bcf 0.2s => [2/4] WORKDIR /app 0.1s => [3/4] ADD . /app 0.2s => [4/4] RUN pip install --trusted-host pypi.python.org -r requirements.txt 5.7s => exporting to image 0.2s => => exporting layers 0.2s => => writing image sha256:c6e96d921302343506b1c228c5840e4f2ffe20a85c60c2d832 0.0s => => naming to docker.io/library/sample-app:v1.0 If you see no errors, congrats you have successfully containerized the application. You can check if the application runs inside the container by running the following command: docker run -p 8080 :8080 sample-app:v1.0 Visit http://0.0.0.0:8080/ on your browser or run the following command: curl http://0.0.0.0:8080 You will see output similar to the following: <h1 align='center'>Hello World from Python Flask!</h1> If you see Hello World message, congrats your containerized application works as expected. Containerize NodeJs Express App 2.1. Create a Dockerfile Create a Dockerfile . In terminal, run the following command: touch Dockerfile Open the Dockerfile in your favourite code editor. Define a base image FROM node:16 Create a working directory WORKDIR /app Add the application source code to the working directory ADD . /app Install dependencies RUN npm install Expose the flask access port EXPOSE 3000 Run the npm run command CMD [ \"npm\" , \"start\" ] Your Dockerfile should look something like this: Dockerfile 1 2 3 4 5 6 7 8 9 10 11 FROM node:16 WORKDIR /app ADD . /app RUN npm install EXPOSE 3000 CMD [ \"npm\" , \"start\" ] Save the file. 2.2. Build Container Image Back to terminal, run the following command to build a container image for the application. docker build -t sample-app:v1.0 . You will see output similar to the following: => [internal] load build definition from Dockerfile 0.0s => => transferring dockerfile: 134B 0.0s => [internal] load .dockerignore 0.0s => => transferring context: 2B 0.0s => [internal] load metadata for docker.io/library/node:16 5.3s => [internal] load build context 0.1s => => transferring context: 1.77MB 0.1s => [1/4] FROM docker.io/library/node:16@sha256:d3d1a02bab20f7956 39.3s => => resolve docker.io/library/node:16@sha256:d3d1a02bab20f7956 0.0s => => sha256:d3d1a02bab20f7956676ff17e901f7c5054114a902a152cbebd 1.21kB / 1.21kB 0.0s => => sha256:842962c4b3a745b6cfc84acf07688a392bcb90af27adb28a6b6 7.60kB / 7.60kB 0.0s => => sha256:b6013b3e77fe6fd3dcf46a05f8e5b3afa9fbca7ba0161c62e56 7.83MB / 7.83MB 4.6s => => sha256:d87a1f3e0b5b2a684aa101fb7259913a13372626aa1de17398d 2.21kB / 2.21kB 0.0s => => sha256:9b99af5931b39ce167150ad668cfa57ddf7664697be9996cb7e 50.44MB / 50.44MB 6.8s => => sha256:bbced17b6899896c8e4016d62c885d737fe667acace2733e17c 10.00MB / 10.00MB 3.5s => => sha256:8b609dabefa83fae157bcd42123a8ed45199bb6c301e09a1126 51.84MB / 51.84MB 16.2s => => sha256:50544bfef33d1d653b7bc10316e20bd84889fd56dd2b7e2f742 192.43MB / 192.43MB 30.2s => => extracting sha256:9b99af5931b39ce167150ad668cfa57ddf766469 2.1s => => sha256:fea3f8b8e0752b4518bab41fb3fa31db44fceb625894b117f3e 4.20kB / 4.20kB 7.1s => => sha256:9e4e229021eebc9d3673e52ada928bc35ba736634fd90c021c5 33.36MB / 33.36MB 16.7s => => extracting sha256:b6013b3e77fe6fd3dcf46a05f8e5b3afa9fbca7b 0.3s => => extracting sha256:bbced17b6899896c8e4016d62c885d737fe667ac 0.3s => => sha256:971c8efc250bdf861d7751378b93dd39d0143f59583b44ce152 2.27MB / 2.27MB 17.6s => => extracting sha256:8b609dabefa83fae157bcd42123a8ed45199bb6c 2.4s => => sha256:3e9d4bc41c274ff79bb76a3ae8553a7932ff87e2401e7ea6c61 449B / 449B 17.4s => => extracting sha256:50544bfef33d1d653b7bc10316e20bd84889fd56 7.0s => => extracting sha256:fea3f8b8e0752b4518bab41fb3fa31db44fceb62 0.1s => => extracting sha256:9e4e229021eebc9d3673e52ada928bc35ba73663 1.3s => => extracting sha256:971c8efc250bdf861d7751378b93dd39d0143f59 0.1s => => extracting sha256:3e9d4bc41c274ff79bb76a3ae8553a7932ff87e2 0.0s => [2/4] WORKDIR /app 0.1s => [3/4] ADD . /app 0.1s => [4/4] RUN npm install 2.3s => exporting to image 0.1s => => exporting layers 0.1s => => writing image sha256:9d26c44d4e20a81041771d79d6af41b348504 0.0s => => naming to docker.io/library/sample-app:1.0 0.0s If you see no errors, congrats you have successfully containerized the application. You can check if the application runs inside the container by running the following command: docker run -p 3000 :3000 sample-app:v1.0 Visit http://0.0.0.0:3000/ on your browser or run the following command: curl http://0.0.0.0:3000 You will see output similar to the following: <h1 align='center'>Hello World from NodeJs Express!</h1> If you see Hello World message, congrats your containerized application works as expected.","title":"2. Containerizing the Application"},{"location":"containerize/#containerize-python-flask-app","text":"","title":"Containerize Python Flask App"},{"location":"containerize/#21-create-a-dockerfile","text":"Create a Dockerfile . In terminal, run the following command: touch Dockerfile Create a python library requirements file by running the following command: pip freeze > requirements.txt This will create a requirements.txt file in the same directory which will contain all the dependencies for the project. Open the Dockerfile in your favourite code editor. Define a base image FROM python:3.9-slim Create a working directory WORKDIR /app Add the app.py and requirements.txt file to the working directory ADD . /app Install the python dependencies RUN pip install --trusted-host pypi.python.org -r requirements.txt Expose the flask access port EXPOSE 8080 Run the python run command CMD [ \"python\" , \"-u\" , \"app.py\" ] Your Dockerfile should look something like this: Dockerfile 1 2 3 4 5 6 7 8 9 10 11 FROM python:3.9-slim WORKDIR /app ADD . /app RUN pip install --trusted-host pypi.python.org -r requirements.txt EXPOSE 8080 CMD [ \"python\" , \"-u\" , \"app.py\" ] Save the file.","title":"2.1. Create a Dockerfile"},{"location":"containerize/#22-build-container-image","text":"Back to terminal, run the following command to build a container image for the application. docker build -t sample-app:v1.0 . You will see output similar to the following: => [internal] load build definition from Dockerfile 0.0s => => transferring dockerfile: 203B 0.0s => [internal] load .dockerignore 0.0s => => transferring context: 2B 0.0s => [internal] load metadata for docker.io/library/python:3.9-slim 4.1s => [auth] library/python:pull token for registry-1.docker.io 0.0s => [internal] load build context 0.3s => => transferring context: 15.34MB 0.3s => [1/4] FROM docker.io/library/python:3.9-slim@sha256:7783d80eca13fb9f8cfd8b 5.7s => => resolve docker.io/library/python:3.9-slim@sha256:7783d80eca13fb9f8cfd8b 0.0s => => sha256:7783d80eca13fb9f8cfd8b84b27ac09ecc28f52bafdd9b94 1.86kB / 1.86kB 0.0s => => sha256:9fa920a5e22c494e2c879fee24f72ba0bb842b8e8e7376ac 1.37kB / 1.37kB 0.0s => => sha256:afaa64e7c7fe503b643b460295b8621f4709ebd058c55c2b 7.63kB / 7.63kB 0.0s => => sha256:69692152171afee1fd341febc390747cfca2ff302f2881 27.15MB / 27.15MB 3.3s => => sha256:59773387c0e7ec4b901649cd3530cde9a32e6a76fccaf0b0 2.77MB / 2.77MB 3.0s => => sha256:3fc84e535e87f5dfd4ab5a3086531224f67051d7f7853c 10.93MB / 10.93MB 4.2s => => sha256:68ebeebdab6f71c7a8dc8532e56ed6d69171502240306980ae78 234B / 234B 4.2s => => extracting sha256:69692152171afee1fd341febc390747cfca2ff302f2881d8b394e 1.2s => => sha256:ada7ec54b5b23c775e12472f8975b1af576ca949c63a7957 2.60MB / 2.60MB 4.2s => => extracting sha256:59773387c0e7ec4b901649cd3530cde9a32e6a76fccaf0b015119 0.2s => => extracting sha256:3fc84e535e87f5dfd4ab5a3086531224f67051d7f7853c659d3dd 0.5s => => extracting sha256:68ebeebdab6f71c7a8dc8532e56ed6d69171502240306980ae78e 0.0s => => extracting sha256:ada7ec54b5b23c775e12472f8975b1af576ca949c63a795703bcf 0.2s => [2/4] WORKDIR /app 0.1s => [3/4] ADD . /app 0.2s => [4/4] RUN pip install --trusted-host pypi.python.org -r requirements.txt 5.7s => exporting to image 0.2s => => exporting layers 0.2s => => writing image sha256:c6e96d921302343506b1c228c5840e4f2ffe20a85c60c2d832 0.0s => => naming to docker.io/library/sample-app:v1.0 If you see no errors, congrats you have successfully containerized the application. You can check if the application runs inside the container by running the following command: docker run -p 8080 :8080 sample-app:v1.0 Visit http://0.0.0.0:8080/ on your browser or run the following command: curl http://0.0.0.0:8080 You will see output similar to the following: <h1 align='center'>Hello World from Python Flask!</h1> If you see Hello World message, congrats your containerized application works as expected.","title":"2.2. Build Container Image"},{"location":"containerize/#containerize-nodejs-express-app","text":"","title":"Containerize NodeJs Express App"},{"location":"containerize/#21-create-a-dockerfile_1","text":"Create a Dockerfile . In terminal, run the following command: touch Dockerfile Open the Dockerfile in your favourite code editor. Define a base image FROM node:16 Create a working directory WORKDIR /app Add the application source code to the working directory ADD . /app Install dependencies RUN npm install Expose the flask access port EXPOSE 3000 Run the npm run command CMD [ \"npm\" , \"start\" ] Your Dockerfile should look something like this: Dockerfile 1 2 3 4 5 6 7 8 9 10 11 FROM node:16 WORKDIR /app ADD . /app RUN npm install EXPOSE 3000 CMD [ \"npm\" , \"start\" ] Save the file.","title":"2.1. Create a Dockerfile"},{"location":"containerize/#22-build-container-image_1","text":"Back to terminal, run the following command to build a container image for the application. docker build -t sample-app:v1.0 . You will see output similar to the following: => [internal] load build definition from Dockerfile 0.0s => => transferring dockerfile: 134B 0.0s => [internal] load .dockerignore 0.0s => => transferring context: 2B 0.0s => [internal] load metadata for docker.io/library/node:16 5.3s => [internal] load build context 0.1s => => transferring context: 1.77MB 0.1s => [1/4] FROM docker.io/library/node:16@sha256:d3d1a02bab20f7956 39.3s => => resolve docker.io/library/node:16@sha256:d3d1a02bab20f7956 0.0s => => sha256:d3d1a02bab20f7956676ff17e901f7c5054114a902a152cbebd 1.21kB / 1.21kB 0.0s => => sha256:842962c4b3a745b6cfc84acf07688a392bcb90af27adb28a6b6 7.60kB / 7.60kB 0.0s => => sha256:b6013b3e77fe6fd3dcf46a05f8e5b3afa9fbca7ba0161c62e56 7.83MB / 7.83MB 4.6s => => sha256:d87a1f3e0b5b2a684aa101fb7259913a13372626aa1de17398d 2.21kB / 2.21kB 0.0s => => sha256:9b99af5931b39ce167150ad668cfa57ddf7664697be9996cb7e 50.44MB / 50.44MB 6.8s => => sha256:bbced17b6899896c8e4016d62c885d737fe667acace2733e17c 10.00MB / 10.00MB 3.5s => => sha256:8b609dabefa83fae157bcd42123a8ed45199bb6c301e09a1126 51.84MB / 51.84MB 16.2s => => sha256:50544bfef33d1d653b7bc10316e20bd84889fd56dd2b7e2f742 192.43MB / 192.43MB 30.2s => => extracting sha256:9b99af5931b39ce167150ad668cfa57ddf766469 2.1s => => sha256:fea3f8b8e0752b4518bab41fb3fa31db44fceb625894b117f3e 4.20kB / 4.20kB 7.1s => => sha256:9e4e229021eebc9d3673e52ada928bc35ba736634fd90c021c5 33.36MB / 33.36MB 16.7s => => extracting sha256:b6013b3e77fe6fd3dcf46a05f8e5b3afa9fbca7b 0.3s => => extracting sha256:bbced17b6899896c8e4016d62c885d737fe667ac 0.3s => => sha256:971c8efc250bdf861d7751378b93dd39d0143f59583b44ce152 2.27MB / 2.27MB 17.6s => => extracting sha256:8b609dabefa83fae157bcd42123a8ed45199bb6c 2.4s => => sha256:3e9d4bc41c274ff79bb76a3ae8553a7932ff87e2401e7ea6c61 449B / 449B 17.4s => => extracting sha256:50544bfef33d1d653b7bc10316e20bd84889fd56 7.0s => => extracting sha256:fea3f8b8e0752b4518bab41fb3fa31db44fceb62 0.1s => => extracting sha256:9e4e229021eebc9d3673e52ada928bc35ba73663 1.3s => => extracting sha256:971c8efc250bdf861d7751378b93dd39d0143f59 0.1s => => extracting sha256:3e9d4bc41c274ff79bb76a3ae8553a7932ff87e2 0.0s => [2/4] WORKDIR /app 0.1s => [3/4] ADD . /app 0.1s => [4/4] RUN npm install 2.3s => exporting to image 0.1s => => exporting layers 0.1s => => writing image sha256:9d26c44d4e20a81041771d79d6af41b348504 0.0s => => naming to docker.io/library/sample-app:1.0 0.0s If you see no errors, congrats you have successfully containerized the application. You can check if the application runs inside the container by running the following command: docker run -p 3000 :3000 sample-app:v1.0 Visit http://0.0.0.0:3000/ on your browser or run the following command: curl http://0.0.0.0:3000 You will see output similar to the following: <h1 align='center'>Hello World from NodeJs Express!</h1> If you see Hello World message, congrats your containerized application works as expected.","title":"2.2. Build Container Image"},{"location":"deploy-script/","text":"Python Flask Application NodeJs Express Application Python Flask App Deployment Script 4.1. Create a Deployment Create a deploy.yaml file. In terminal, run the following command: touch deploy.yaml Open the deploy.yaml file in your favourite code editor. Set the API version to v1 and the kind to Deployment . apiVersion : apps/v1 kind : Deployment Define the metadata for the deployment. metadata : name : sample-app labels : app : flask Define the spec for the deployment. Add the container image name as a value for the image: key. spec : replicas : 1 selector : matchLabels : app : flask template : metadata : labels : app : flask spec : containers : - name : sample-app image : <username>/sample-app:v1.0 ports : - containerPort : 8080 Your deploy.yaml file should look something like this: deploy.yaml 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 apiVersion : apps/v1 # for versions before 1.9.0 use apps/v1beta2 kind : Deployment metadata : name : sample-app labels : app : flask spec : replicas : 1 selector : matchLabels : app : flask template : metadata : labels : app : flask spec : containers : - name : sample-app image : <username>/sample-app:v1.0 ports : - containerPort : 8080 Save the file. 4.2. Create a Service Create a service.yaml file. In terminal, run the following command: touch service.yaml Open the service.yaml file in your favourite code editor. Set the API version to v1 and the kind to Service . apiVersion : v1 kind : Service Define the metadata for the deployment. metadata : name : my-flask-app-service Define the spec for the deployment. spec : selector : app : flask ports : - protocol : TCP port : 8080 targetPort : 8080 nodePort : 32200 type : NodePort Your service.yaml file should look something like this: service.yaml 1 2 3 4 5 6 7 8 9 10 11 12 13 apiVersion : v1 kind : Service metadata : name : my-flask-app-service spec : selector : app : flask ports : - protocol : TCP port : 8080 targetPort : 8080 nodePort : 32200 type : NodePort Save the file. NodeJs Express App Deployment Script 4.1. Create a Deployment Create a deploy.yaml file. In terminal, run the following command: touch deploy.yaml Open the deploy.yaml file in your favourite code editor. Set the API version to v1 and the kind to Deployment . apiVersion : apps/v1 kind : Deployment Define the metadata for the deployment. metadata : name : sample-app labels : app : express Define the spec for the deployment. Add the container image name as a value for the image: key. spec : replicas : 1 selector : matchLabels : app : express template : metadata : labels : app : express spec : containers : - name : sample-app image : <username>/sample-app:v1.0 ports : - containerPort : 3000 Your deploy.yaml file should look something like this: deploy.yaml 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 apiVersion : apps/v1 # for versions before 1.9.0 use apps/v1beta2 kind : Deployment metadata : name : sample-app labels : app : express spec : replicas : 1 selector : matchLabels : app : express template : metadata : labels : app : express spec : containers : - name : sample-app image : <username>/sample-app:v1.0 ports : - containerPort : 3000 Save the file. 4.2. Create a Service Create a service.yaml file. In terminal, run the following command: touch service.yaml Open the service.yaml file in your favourite code editor. Set the API version to v1 and the kind to Service . apiVersion : v1 kind : Service Define the metadata for the deployment. metadata : name : my-express-app-service Define the spec for the deployment. spec : selector : app : express ports : - protocol : TCP port : 80 targetPort : 3000 nodePort : 32201 type : NodePort Your service.yaml file should look something like this: service.yaml 1 2 3 4 5 6 7 8 9 10 11 12 13 apiVersion : v1 kind : Service metadata : name : my-express-app-service spec : selector : app : express ports : - protocol : TCP port : 80 targetPort : 3000 nodePort : 32201 type : NodePort Save the file. Learning Materials Yaml Checker provides a quick and easy way to validate YAML Learn more about Kubernetes Deployments Learn more about Kubernetes Service Learn more about Kubernetes Pods","title":"4. Writing the deployment scripts"},{"location":"deploy-script/#python-flask-app-deployment-script","text":"","title":"Python Flask App Deployment Script"},{"location":"deploy-script/#41-create-a-deployment","text":"Create a deploy.yaml file. In terminal, run the following command: touch deploy.yaml Open the deploy.yaml file in your favourite code editor. Set the API version to v1 and the kind to Deployment . apiVersion : apps/v1 kind : Deployment Define the metadata for the deployment. metadata : name : sample-app labels : app : flask Define the spec for the deployment. Add the container image name as a value for the image: key. spec : replicas : 1 selector : matchLabels : app : flask template : metadata : labels : app : flask spec : containers : - name : sample-app image : <username>/sample-app:v1.0 ports : - containerPort : 8080 Your deploy.yaml file should look something like this: deploy.yaml 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 apiVersion : apps/v1 # for versions before 1.9.0 use apps/v1beta2 kind : Deployment metadata : name : sample-app labels : app : flask spec : replicas : 1 selector : matchLabels : app : flask template : metadata : labels : app : flask spec : containers : - name : sample-app image : <username>/sample-app:v1.0 ports : - containerPort : 8080 Save the file.","title":"4.1. Create a Deployment"},{"location":"deploy-script/#42-create-a-service","text":"Create a service.yaml file. In terminal, run the following command: touch service.yaml Open the service.yaml file in your favourite code editor. Set the API version to v1 and the kind to Service . apiVersion : v1 kind : Service Define the metadata for the deployment. metadata : name : my-flask-app-service Define the spec for the deployment. spec : selector : app : flask ports : - protocol : TCP port : 8080 targetPort : 8080 nodePort : 32200 type : NodePort Your service.yaml file should look something like this: service.yaml 1 2 3 4 5 6 7 8 9 10 11 12 13 apiVersion : v1 kind : Service metadata : name : my-flask-app-service spec : selector : app : flask ports : - protocol : TCP port : 8080 targetPort : 8080 nodePort : 32200 type : NodePort Save the file.","title":"4.2. Create a Service"},{"location":"deploy-script/#nodejs-express-app-deployment-script","text":"","title":"NodeJs Express App Deployment Script"},{"location":"deploy-script/#41-create-a-deployment_1","text":"Create a deploy.yaml file. In terminal, run the following command: touch deploy.yaml Open the deploy.yaml file in your favourite code editor. Set the API version to v1 and the kind to Deployment . apiVersion : apps/v1 kind : Deployment Define the metadata for the deployment. metadata : name : sample-app labels : app : express Define the spec for the deployment. Add the container image name as a value for the image: key. spec : replicas : 1 selector : matchLabels : app : express template : metadata : labels : app : express spec : containers : - name : sample-app image : <username>/sample-app:v1.0 ports : - containerPort : 3000 Your deploy.yaml file should look something like this: deploy.yaml 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 apiVersion : apps/v1 # for versions before 1.9.0 use apps/v1beta2 kind : Deployment metadata : name : sample-app labels : app : express spec : replicas : 1 selector : matchLabels : app : express template : metadata : labels : app : express spec : containers : - name : sample-app image : <username>/sample-app:v1.0 ports : - containerPort : 3000 Save the file.","title":"4.1. Create a Deployment"},{"location":"deploy-script/#42-create-a-service_1","text":"Create a service.yaml file. In terminal, run the following command: touch service.yaml Open the service.yaml file in your favourite code editor. Set the API version to v1 and the kind to Service . apiVersion : v1 kind : Service Define the metadata for the deployment. metadata : name : my-express-app-service Define the spec for the deployment. spec : selector : app : express ports : - protocol : TCP port : 80 targetPort : 3000 nodePort : 32201 type : NodePort Your service.yaml file should look something like this: service.yaml 1 2 3 4 5 6 7 8 9 10 11 12 13 apiVersion : v1 kind : Service metadata : name : my-express-app-service spec : selector : app : express ports : - protocol : TCP port : 80 targetPort : 3000 nodePort : 32201 type : NodePort Save the file. Learning Materials Yaml Checker provides a quick and easy way to validate YAML Learn more about Kubernetes Deployments Learn more about Kubernetes Service Learn more about Kubernetes Pods","title":"4.2. Create a Service"},{"location":"deploy/","text":"5.1. Create a Kubernetes cluster Managed Kubernetes Service (Paid) You can procure a managed Kubernetes service from the following providers: Create an EKS cluster on AWS - Managed Kubernetes service from AWS Create an IKS cluster on IBM Cloud - Managed Kubernetes service from IBM Cloud Create an AKS cluster on Azure - Managed Kubernetes service from Azure Create a GKE cluster on GCP - Managed Kubernetes service from Google Cloud Platform (GCP) Local Kubernetes Service (Free) You can use local Kubernetes cluster provided by Docker Desktop. To Enable this, install Docker Desktop and open it. Click on the gear icon on top. Select Kubernetes from the list. Click on Enable Kubernetes checkbox. Click on Apply and Restart . Note: Kubernetes installation for Docker Desktop takes a few minutes and requires an internet connection. Once enabled, please wait for the Kubernetes cluster to start. You can verify the successful start by checking the color of the Kubernetes cluster icon in the bottom left corner of the Docker Desktop window. The cluster icon will turn green when the cluster is ready. 5.2. Check Kubernetes context Once you have a Kubernetes cluster ready to use, you need to point your kubectl to the Kubernetes cluster. You can check the context by running the following command: kubectl config current-context If you have setup local Kubernetes cluster with Docker Desktop, you will see output similar to the following: docker-desktop Important Note If you have setup a managed Kubernetes cluster, your output may vary. Once you verify kubectl is pointing to the Kubernetes cluster, you can proceed to the next step. If kubectl is not pointing to the Kubernetes cluster, you can refer to Managing Kubernetes Context using Kubectl medium article which explains how to set the context. 5.3. Deploy App on Kubernetes You will be using the deploy.yaml script file to deploy the app on the Kubernetes cluster. In terminal, run the following command: kubectl apply -f deploy.yaml You will see output similar to the following: deployment.apps/sample-app created You can see the deployment on your Kubernetes cluster by running the following command: kubectl get deployment You will see output similar to the following: NAME READY UP-TO-DATE AVAILABLE AGE sample-app 1/1 1 1 6s You can also check the pods for the deployment by running the following command: kubectl get pods You will see output similar to the following: NAME READY STATUS RESTARTS AGE sample-app-7c7f988df8-rt76v 1/1 Running 0 4s Remember we had set the replicas to 1 in the deploy.yaml file. So, you will see only one pod running. You can increase the number of replicas by running the following command: kubectl scale deployment sample-app --replicas = 2 You will see output similar to the following: deployment.apps/sample-app scaled Now if you check the pods you will see two pods running. kubectl get pods You will see output similar to the following: NAME READY STATUS RESTARTS AGE sample-app-7c7f988df8-rt76v 1/1 Running 0 58s sample-app-7c7f988df8-sw89l 1/1 Running 0 54s You can check if the application is running inside the pod. In terminal, run the following command: kubectl logs sample-app-7c7f988df8-666zb You will see output similar to the following: Python Flask App Output * Serving Flask app 'app' (lazy loading) * Environment: production WARNING: This is a development server. Do not use it in a production deployment. Use a production WSGI server instead. * Debug mode: on * Running on all addresses. WARNING: This is a development server. Do not use it in a production deployment. * Running on http://10.1.0.34:8080/ (Press CTRL+C to quit) * Restarting with stat * Debugger is active! * Debugger PIN: 113-374-682 NodeJs Express App Output > express-app@1.0.0 start > node app.js Example app listening on port 3000! If you have followed the tutorial upto this point, the application will be running successfully inside the pod. To access the application you need to create a service. 5.4. Create service for the deployment A service for deployment is created to access the application from outside the cluster. The service exposes a port from the deployment. You can expose port from the service in three ways: Types Expose Access Example ClusterIP Expose service through kubernetes cluster Access service through clusterIP:port http://192.168.29.2:5432 NodePort Expose service through internal network VM's (external to kubernetes) Access service through clusterIP:nodePort http://192.168.29.2:30000 (note: nodePort is always in the range 30000-32767) LoadBalancer Expose service through external load balancer (external world) Access service through externalIP:port https://sample-app.amazonaws.com You will be using the service.yaml script file to create a service for the deployment. In terminal, run the following command: kubectl apply -f service.yaml You will see output similar to the following: service/sample-app created To check the service that you just created, run the following command: kubectl get service You will see output similar to the following: Python Flask App Output NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE kubernetes ClusterIP 10.96.0.1 <none> 443/TCP 5h8m my-flask-app-service NodePort 10.104.140.122 <none> 80:32200/TCP 5h7m NodeJs Express App Output NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE kubernetes ClusterIP 10.96.0.1 <none> 443/TCP 5h8m my-express-app-service NodePort 10.104.140.122 <none> 80:32201/TCP 5h7m Remember we had set the type to nodePort in the service.yaml file. So, you will have to access the service with clusterIP:nodePort . To get the ClusterIP run the following command: kubectl get nodes -o wide | awk '{print $7}' If you have setup local Kubernetes cluster with Docker Desktop, you will see output similar to the following: EXTERNAL-IP <none> Important Note If you have setup a managed Kubernetes cluster, your output may vary. If you see multiple external IPs displayed, you can use any one of the external IPs. Note Since local Kubernetes cluster is running on your machine, you will see <none> in the EXTERNAL-IP column. However, you can access the clusterIP:nodePort by simply visiting localhost:nodePort . Access Python Flask Application from Kubernetes Access NodeJs Express Application from Kubernetes To access the python flask application, visit http://localhost:32200/ on your browser or run the following command: curl http://localhost:32200 Note: Remember we had defined nodePort:32200 in the service.yaml file for python flask application. Also localhost is for local Kubernetes cluster. If you have setup a managed Kubernetes cluster, use the External-IP obtained from kubectl get nodes -o wide | awk '{print $7}' and the port 32200 . You will see output similar to the following: <h1 align='center'>Hello World from Python Flask!</h1> To access the nodejs express application, visit http://localhost:32201/ on your browser or run the following command: curl http://localhost:32201 Note: Remember we had defined nodePort:32201 in the service.yaml file for nodejs express application. Also localhost is for local Kubernetes cluster. If you have setup a managed Kubernetes cluster, use the External-IP obtained from kubectl get nodes -o wide | awk '{print $7}' and the port 32201 . You will see output similar to the following: <h1 align='center'>Hello World from NodeJs Express!</h1> If you see Hello World message, congrats! You have successfully deployed the application on a Kubernetes cluster. Learning Materials Learn Kubernetes Basics Running Multiple Instances of Your App (scaling the app)","title":"5. Deploying the application on a Kubernetes cluster"},{"location":"deploy/#51-create-a-kubernetes-cluster","text":"Managed Kubernetes Service (Paid) You can procure a managed Kubernetes service from the following providers: Create an EKS cluster on AWS - Managed Kubernetes service from AWS Create an IKS cluster on IBM Cloud - Managed Kubernetes service from IBM Cloud Create an AKS cluster on Azure - Managed Kubernetes service from Azure Create a GKE cluster on GCP - Managed Kubernetes service from Google Cloud Platform (GCP) Local Kubernetes Service (Free) You can use local Kubernetes cluster provided by Docker Desktop. To Enable this, install Docker Desktop and open it. Click on the gear icon on top. Select Kubernetes from the list. Click on Enable Kubernetes checkbox. Click on Apply and Restart . Note: Kubernetes installation for Docker Desktop takes a few minutes and requires an internet connection. Once enabled, please wait for the Kubernetes cluster to start. You can verify the successful start by checking the color of the Kubernetes cluster icon in the bottom left corner of the Docker Desktop window. The cluster icon will turn green when the cluster is ready.","title":"5.1. Create a Kubernetes cluster"},{"location":"deploy/#52-check-kubernetes-context","text":"Once you have a Kubernetes cluster ready to use, you need to point your kubectl to the Kubernetes cluster. You can check the context by running the following command: kubectl config current-context If you have setup local Kubernetes cluster with Docker Desktop, you will see output similar to the following: docker-desktop Important Note If you have setup a managed Kubernetes cluster, your output may vary. Once you verify kubectl is pointing to the Kubernetes cluster, you can proceed to the next step. If kubectl is not pointing to the Kubernetes cluster, you can refer to Managing Kubernetes Context using Kubectl medium article which explains how to set the context.","title":"5.2. Check Kubernetes context"},{"location":"deploy/#53-deploy-app-on-kubernetes","text":"You will be using the deploy.yaml script file to deploy the app on the Kubernetes cluster. In terminal, run the following command: kubectl apply -f deploy.yaml You will see output similar to the following: deployment.apps/sample-app created You can see the deployment on your Kubernetes cluster by running the following command: kubectl get deployment You will see output similar to the following: NAME READY UP-TO-DATE AVAILABLE AGE sample-app 1/1 1 1 6s You can also check the pods for the deployment by running the following command: kubectl get pods You will see output similar to the following: NAME READY STATUS RESTARTS AGE sample-app-7c7f988df8-rt76v 1/1 Running 0 4s Remember we had set the replicas to 1 in the deploy.yaml file. So, you will see only one pod running. You can increase the number of replicas by running the following command: kubectl scale deployment sample-app --replicas = 2 You will see output similar to the following: deployment.apps/sample-app scaled Now if you check the pods you will see two pods running. kubectl get pods You will see output similar to the following: NAME READY STATUS RESTARTS AGE sample-app-7c7f988df8-rt76v 1/1 Running 0 58s sample-app-7c7f988df8-sw89l 1/1 Running 0 54s You can check if the application is running inside the pod. In terminal, run the following command: kubectl logs sample-app-7c7f988df8-666zb You will see output similar to the following: Python Flask App Output * Serving Flask app 'app' (lazy loading) * Environment: production WARNING: This is a development server. Do not use it in a production deployment. Use a production WSGI server instead. * Debug mode: on * Running on all addresses. WARNING: This is a development server. Do not use it in a production deployment. * Running on http://10.1.0.34:8080/ (Press CTRL+C to quit) * Restarting with stat * Debugger is active! * Debugger PIN: 113-374-682 NodeJs Express App Output > express-app@1.0.0 start > node app.js Example app listening on port 3000! If you have followed the tutorial upto this point, the application will be running successfully inside the pod. To access the application you need to create a service.","title":"5.3. Deploy App on Kubernetes"},{"location":"deploy/#54-create-service-for-the-deployment","text":"A service for deployment is created to access the application from outside the cluster. The service exposes a port from the deployment. You can expose port from the service in three ways: Types Expose Access Example ClusterIP Expose service through kubernetes cluster Access service through clusterIP:port http://192.168.29.2:5432 NodePort Expose service through internal network VM's (external to kubernetes) Access service through clusterIP:nodePort http://192.168.29.2:30000 (note: nodePort is always in the range 30000-32767) LoadBalancer Expose service through external load balancer (external world) Access service through externalIP:port https://sample-app.amazonaws.com You will be using the service.yaml script file to create a service for the deployment. In terminal, run the following command: kubectl apply -f service.yaml You will see output similar to the following: service/sample-app created To check the service that you just created, run the following command: kubectl get service You will see output similar to the following: Python Flask App Output NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE kubernetes ClusterIP 10.96.0.1 <none> 443/TCP 5h8m my-flask-app-service NodePort 10.104.140.122 <none> 80:32200/TCP 5h7m NodeJs Express App Output NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE kubernetes ClusterIP 10.96.0.1 <none> 443/TCP 5h8m my-express-app-service NodePort 10.104.140.122 <none> 80:32201/TCP 5h7m Remember we had set the type to nodePort in the service.yaml file. So, you will have to access the service with clusterIP:nodePort . To get the ClusterIP run the following command: kubectl get nodes -o wide | awk '{print $7}' If you have setup local Kubernetes cluster with Docker Desktop, you will see output similar to the following: EXTERNAL-IP <none> Important Note If you have setup a managed Kubernetes cluster, your output may vary. If you see multiple external IPs displayed, you can use any one of the external IPs. Note Since local Kubernetes cluster is running on your machine, you will see <none> in the EXTERNAL-IP column. However, you can access the clusterIP:nodePort by simply visiting localhost:nodePort . Access Python Flask Application from Kubernetes Access NodeJs Express Application from Kubernetes To access the python flask application, visit http://localhost:32200/ on your browser or run the following command: curl http://localhost:32200 Note: Remember we had defined nodePort:32200 in the service.yaml file for python flask application. Also localhost is for local Kubernetes cluster. If you have setup a managed Kubernetes cluster, use the External-IP obtained from kubectl get nodes -o wide | awk '{print $7}' and the port 32200 . You will see output similar to the following: <h1 align='center'>Hello World from Python Flask!</h1> To access the nodejs express application, visit http://localhost:32201/ on your browser or run the following command: curl http://localhost:32201 Note: Remember we had defined nodePort:32201 in the service.yaml file for nodejs express application. Also localhost is for local Kubernetes cluster. If you have setup a managed Kubernetes cluster, use the External-IP obtained from kubectl get nodes -o wide | awk '{print $7}' and the port 32201 . You will see output similar to the following: <h1 align='center'>Hello World from NodeJs Express!</h1> If you see Hello World message, congrats! You have successfully deployed the application on a Kubernetes cluster. Learning Materials Learn Kubernetes Basics Running Multiple Instances of Your App (scaling the app)","title":"5.4. Create service for the deployment"},{"location":"store/","text":"3.1. Push the container image to DockerHub Now that you have your application containerized, you can store it in a container registry such as dockerhub. Storing static container images in container registry is required to deploy application on a remote kubernetes cluster. Login to docker by running the following command: docker login You will see output similar to the following: Login with your Docker ID to push and pull images from Docker Hub. If you don't have a Docker ID, head over to https://hub.docker.com to create one. Username: manojjahgirdar Password: Login Succeeded Rename the container image in the format username/imagename:tag by running the following command: docker tag sample-app:v1.0 <username>/sample-app:v1.0 Push the image to docker hub by running the following command: docker push <username>/sample-app:v1.0 You will see output similar to the following: Python Flask Output The push refers to repository [docker.io/manojjahgirdar/sample-app] c51c5d086047: Pushed c37b64c6b724: Pushed af602c0dc044: Pushed a765872192e3: Mounted from library/python a6dfc8291750: Mounted from library/python 7e46f0272529: Mounted from library/python 5359ff267161: Mounted from library/python 2edcec3590a4: Mounted from library/python 1.0: digest: sha256:db6ad330c4d5e5df3728b4b3123129e9a0449f0becba21a7b681f8f773d7ba38 size: 1999 NodeJs Express Output The push refers to repository [docker.io/manojjahgirdar/sample-app] 166293c07cb0: Pushed c01bf11fccb2: Pushed 56034ba0dab4: Pushed 70b4fdd67645: Mounted from library/node b77fe0f00494: Mounted from library/node 9b5ca33009b8: Mounted from library/node 75b4edf780e2: Mounted from library/node 126712f9d0fb: Mounted from library/node 330a6fb3364f: Mounted from library/node b20560b6a21c: Mounted from library/node a1215953fc64: Mounted from library/node b14cb48b3aeb: Mounted from library/node v1.0: digest: sha256:e15a8a285030922451616efb88bb2362a302fcbd4f9032e080534f464fde343b size: 2841 You can check the image in https://hub.docker.com","title":"3. Storing the container image in a container registry"},{"location":"store/#31-push-the-container-image-to-dockerhub","text":"Now that you have your application containerized, you can store it in a container registry such as dockerhub. Storing static container images in container registry is required to deploy application on a remote kubernetes cluster. Login to docker by running the following command: docker login You will see output similar to the following: Login with your Docker ID to push and pull images from Docker Hub. If you don't have a Docker ID, head over to https://hub.docker.com to create one. Username: manojjahgirdar Password: Login Succeeded Rename the container image in the format username/imagename:tag by running the following command: docker tag sample-app:v1.0 <username>/sample-app:v1.0 Push the image to docker hub by running the following command: docker push <username>/sample-app:v1.0 You will see output similar to the following: Python Flask Output The push refers to repository [docker.io/manojjahgirdar/sample-app] c51c5d086047: Pushed c37b64c6b724: Pushed af602c0dc044: Pushed a765872192e3: Mounted from library/python a6dfc8291750: Mounted from library/python 7e46f0272529: Mounted from library/python 5359ff267161: Mounted from library/python 2edcec3590a4: Mounted from library/python 1.0: digest: sha256:db6ad330c4d5e5df3728b4b3123129e9a0449f0becba21a7b681f8f773d7ba38 size: 1999 NodeJs Express Output The push refers to repository [docker.io/manojjahgirdar/sample-app] 166293c07cb0: Pushed c01bf11fccb2: Pushed 56034ba0dab4: Pushed 70b4fdd67645: Mounted from library/node b77fe0f00494: Mounted from library/node 9b5ca33009b8: Mounted from library/node 75b4edf780e2: Mounted from library/node 126712f9d0fb: Mounted from library/node 330a6fb3364f: Mounted from library/node b20560b6a21c: Mounted from library/node a1215953fc64: Mounted from library/node b14cb48b3aeb: Mounted from library/node v1.0: digest: sha256:e15a8a285030922451616efb88bb2362a302fcbd4f9032e080534f464fde343b size: 2841 You can check the image in https://hub.docker.com","title":"3.1. Push the container image to DockerHub"}]}